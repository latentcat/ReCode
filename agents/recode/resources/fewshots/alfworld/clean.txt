[Input]
当前要展开的函数是：
solve(instruction, observation)
你可以使用的变量是：
- instruction (str): 你的任务是：清洗一些苹果并将其放在茶几上。
- observation (str): 你在房间中间。快速环顾四周，你看到一个橱柜 4、橱柜 3、橱柜 2、橱柜 1、咖啡机 1、台面 1、餐桌 3、餐桌 2、餐桌 1、抽屉 1、冰箱 1、垃圾桶 1、微波炉 1、茶几 1、水槽 1、炉灶 4、炉灶 3、炉灶 2、炉灶 1 和烤面包机 1。

[Output]
首先我描述任务：物品是一个苹果，必须清洗（所以清洗站是唯一的水槽）并最终放在茶几上。初始观察提供了一个单独的 `水槽 1` 和 `茶几 1`，所以我保留这两个 ID。我还从初始观察中解析并保留所有位置 ID 以便稍后搜索。展开应该分解为三个具体阶段：（1）通过搜索可打开和不可打开的容器来获取苹果；需要时通过打开处理关闭；一旦找到，用确切的 ID 拿起苹果；（2）严格在水槽清洗；（3）放在目标表面上，确保可以到达（表面是不可打开的，所以导航就足够了）。典型错误包括在没有从观察中提取的情况下假设物品 ID，在拿取之前忘记打开关闭的容器，或尝试在水槽以外的地方清洗。


<execute>
cleaning_location_ID = '水槽 1'
target_location_ID = '茶几 1'
obj = 'apple'
all_location_IDs = re.findall(r'[a-z]+(?:[a-z]+)? \d+', observation)

obj_ID = find_and_take(obj, all_location_IDs)
clean_with(obj_ID, cleaning_location_ID)
put_in(obj_ID, target_location_ID)
</execute>


[Input]
当前要展开的函数是：
solve(instruction, observation)
你可以使用的变量是：
- instruction (str): 你的任务是：将干净的生菜放在餐桌上。
- observation (str): 你在房间中间。快速环顾四周，你看到一个橱柜 13、橱柜 12、橱柜 11、橱柜 10、橱柜 9、橱柜 8、橱柜 7、橱柜 6、橱柜 5、橱柜 4、橱柜 3、橱柜 2、橱柜 1、咖啡机 1、台面 1、餐桌 1、抽屉 1、冰箱 1、垃圾桶 1、微波炉 1、架子 3、架子 2、架子 1、水槽 1、炉灶 4、炉灶 3、炉灶 2、炉灶 1 和烤面包机 1。

[Output]
需要的物品是生菜，最终位置是餐桌。清洗步骤是强制性的，必须使用唯一的 `水槽 1`。我会保留 `水槽 1` 作为清洗站，`餐桌 1` 作为目标。我还将从初始观察构建 `all_location_IDs`。分解与之前的情况相似：系统地搜索并拿起生菜，在水槽清洗，然后导航到餐桌并放置物品。我必须小心在拿取之前打开任何关闭的存储（例如，橱柜、抽屉、冰箱、微波炉），并避免移动到关闭的容器中。最后，我将确保正则表达式从观察中提取确切的生菜 ID。


<execute>
cleaning_location_ID = '水槽 1'
target_location_ID = '餐桌 1'
obj = 'lettuce'
all_location_IDs = re.findall(r'[a-z]+(?:[a-z]+)? \d+', observation)

obj_ID = find_and_take(obj, all_location_IDs)
clean_with(obj_ID, cleaning_location_ID)
put_in(obj_ID, target_location_ID)
</execute>




[Input]
当前要展开的函数是：
obj_ID = find_and_take(obj, all_location_IDs)
你可以使用的变量是：
- obj (str): apple
- all_location_IDs (list[str]): ['cabinet 4', 'cabinet 3', 'cabinet 2', 'cabinet 1', 'coffeemachine 1', 'countertop 1', 'diningtable 3', 'diningtable 2', 'diningtable 1', 'drawer 1', 'fridge 1', 'garbagecan 1', 'microwave 1', 'sidetable 1', 'sinkbasin 1', 'stoveburner 4', 'stoveburner 3', 'stoveburner 2', 'stoveburner 1', 'toaster 1']

[Output]
目标是有条理地在房间里导航以找到目标物品的任何实例并拿起它。我将遍历已知位置，总是先导航。如果一个位置没有产生新信息，我会检查它。当一个位置关闭时，我会在搜索前打开它。一旦我观察到具体的 `{obj} k` 提到，我会解析那个确切的 ID 并从当前位置拿起它。常见错误包括导航后不检查（遗漏物品）、未能打开关闭的容器，或在没有完整 `obj_ID` 的情况下拿取。


<execute>
for location_ID in all_location_IDs:
    obs = run(f'go to {location_ID}')
    if 'Nothing happens.' in obs:
        obs = run(f'examine {location_ID}')
    location_closed = 'closed' in obs
    if location_closed:
        obs = run(f'open {location_ID}')
    if f" {obj} " in obs: # 防止名称包含关系
        obj_ID = re.search(rf'\b{obj} \d+\b', obs).group()
        run(f'take {obj_ID} from {location_ID}')
        break
</execute>




[Input]
当前要展开的函数是：
clean_with(obj_ID, cleaning_location_ID)
你可以使用的变量是：
- obj_ID (str): apple 1
- cleaning_location_ID (str): sinkbasin 1

[Output]
清洗必须只能在水槽进行。我将明确导航到记录的清洗站并使用确切的物品 ID 发布清洗命令。我不需要打开水槽；我只需要在那里。一个典型的错误是尝试在其他地方清洗或忘记先导航。


<execute>
run(f'go to {cleaning_location_ID}')
run(f'clean {obj_ID} with {cleaning_location_ID}')
</execute>




[Input]
当前要展开的函数是：
put_in(obj_ID, target_location_ID)
你可以使用的变量是：
- obj_ID (str): apple 1
- target_location_ID (str): sidetable 1

[Output]
我会导航到目标位置，如果没有发生任何事情就检查它，确定它是否关闭，如果需要就打开。然后我会把物品移入里面。这个逻辑支持容器（可打开）和表面（不可打开，但检查也无害）。常见错误：在 `examine` 中使用错误的 ID 或跳过 `location_closed` 检查。


<execute>
obs = run(f'go to {target_location_ID}')
if 'Nothing happens.' in obs:
    obs = run(f'examine {target_location_ID}')
location_closed = 'closed' in obs
if location_closed:
    obs = run(f'open {target_location_ID}')
run(f'move {obj_ID} to {target_location_ID}')
</execute>
