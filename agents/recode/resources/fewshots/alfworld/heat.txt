[Input]
当前要展开的函数是：
solve(instruction, observation)
你可以使用的变量是：
- instruction (str): 你的任务是：加热一些鸡蛋并将其放在餐桌上。
- observation (str): 你在房间中间。快速环顾四周，你看到一个橱柜 10、橱柜 9、橱柜 8、橱柜 7、橱柜 6、橱柜 5、橱柜 4、橱柜 3、橱柜 2、橱柜 1、咖啡机 1、台面 3、台面 2、台面 1、餐桌 1、抽屉 6、抽屉 5、抽屉 4、抽屉 3、抽屉 2、抽屉 1、冰箱 1、垃圾桶 1、微波炉 1、水槽 1、炉灶 4、炉灶 3、炉灶 2、炉灶 1 和烤面包机 1。

[Output]
我必须生成一个加热计划并保持高层次。加热只对微波炉（微波炉 1）有效。最终放置表面是 `餐桌 1`。我将（1）提取 `all_location_IDs`，（2）设置 `heating_location_ID` 和 `target_location_ID`，（3）通过占位符获取鸡蛋，（4）通过针对微波炉的占位符加热，（5）通过通用 put 辅助函数放置。主要错误是省略 `heat_with(...)` 步骤或在这里扩展为低级的 `open/examine` 链，而不是使用占位符。


<execute>
heating_location_ID = '微波炉 1'
target_location_ID = '餐桌 1'
obj = 'egg'
all_location_IDs = re.findall(r'[a-z]+(?:[a-z]+)? \d+', observation)

obj_ID = find_and_take(obj, all_location_IDs)
heat_with(obj_ID, heating_location_ID)
put_in(obj_ID, target_location_ID)
</execute>




[Input]
现在你需要展开的是：
put_a_hot_apple_in_fridge()

当前要展开的函数是：
solve(instruction, observation)
你可以使用的变量是：
- instruction (str): 你的任务是：将热苹果放在冰箱里。
- observation (str): 你在房间中间。快速环顾四周，你看到一个橱柜 13、橱柜 12、橱柜 11、橱柜 10、橱柜 9、橱柜 8、橱柜 7、橱柜 6、橱柜 5、橱柜 4、橱柜 3、橱柜 2、橱柜 1、咖啡机 1、台面 1、餐桌 1、抽屉 1、冰箱 1、垃圾桶 1、微波炉 1、架子 3、架子 2、架子 1、水槽 1、炉灶 4、炉灶 3、炉灶 2、炉灶 1 和烤面包机 1。

[Output]
"热苹果"不是预先存在的；我必须在微波炉 1 加热一个苹果，然后将其放入冰箱 1 中。我会解析位置，找到一个基本的 'apple'，加热它，然后把它放进冰箱（put 辅助函数处理关闭的容器）。常见错误：尝试直接找到"热苹果"，在微波炉以外的地方加热，或在放置前忘记加热。


<execute>
heating_location_ID = '微波炉 1'
target_location_ID = '冰箱 1'
obj = 'apple'
all_location_IDs = re.findall(r'[a-z]+(?:[a-z]+)? \d+', observation)

obj_ID = find_and_take(obj, all_location_IDs)
heat_with(obj_ID, heating_location_ID)
put_in(obj_ID, target_location_ID)
</execute>




[Input]
当前要展开的函数是：
obj_ID = find_and_take(obj, all_location_IDs)
你可以使用的变量是：
- obj (str): apple
- all_location_IDs (list[str]): ['cabinet 4', 'cabinet 3', 'cabinet 2', 'cabinet 1', 'coffeemachine 1', 'countertop 1', 'diningtable 3', 'diningtable 2', 'diningtable 1', 'drawer 1', 'fridge 1', 'garbagecan 1', 'microwave 1', 'sidetable 1', 'sinkbasin 1', 'stoveburner 4', 'stoveburner 3', 'stoveburner 2', 'stoveburner 1', 'toaster 1']

[Output]
目标是有条理地在房间里导航以找到目标物品的任何实例并拿起它。我将遍历已知位置，总是先导航。如果一个位置没有产生新信息，我会检查它。当一个位置关闭时，我会在搜索前打开它。一旦我观察到具体的 `{obj} k` 提到，我会解析那个确切的 ID 并从当前位置拿起它。常见错误包括导航后不检查（遗漏物品）、未能打开关闭的容器，或在没有完整 `obj_ID` 的情况下拿取。


<execute>
for location_ID in all_location_IDs:
    obs = run(f'go to {location_ID}')
    if 'Nothing happens.' in obs:
        obs = run(f'examine {location_ID}')
    location_closed = 'closed' in obs
    if location_closed:
        obs = run(f'open {location_ID}')
    if f" {obj} " in obs: # 防止名称包含关系
        obj_ID = re.search(rf'\b{obj} \d+\b', obs).group()
        run(f'take {obj_ID} from {location_ID}')
        break
</execute>




[Input]
当前要展开的函数是：
heat_with(obj_ID, heating_location_ID)
你可以使用的变量是：
- obj_ID (str): apple 1
- heating_location_ID (str): microwave 1

[Output]
加热只对微波炉有效。我特意保持这个辅助函数最小化以避免过度展开：导航到微波炉并发布加热命令。常见错误：使用非微波炉 ID 或在上游计划中省略加热步骤。


<execute>
run(f'go to {heating_location_ID}')
run(f'heat {obj_ID} with {heating_location_ID}')
</execute>




[Input]
当前要展开的函数是：
put_in(obj_ID, target_location_ID)
你可以使用的变量是：
- obj_ID (str): apple 1
- target_location_ID (str): sidetable 1

[Output]
我会导航到目标位置，如果没有发生任何事情就检查它，确定它是否关闭，如果需要就打开。然后我会把物品移入里面。这个逻辑支持容器（可打开）和表面（不可打开，但检查也无害）。常见错误：在 `examine` 中使用错误的 ID 或跳过 `location_closed` 检查。


<execute>
obs = run(f'go to {target_location_ID}')
if 'Nothing happens.' in obs:
    obs = run(f'examine {target_location_ID}')
location_closed = 'closed' in obs
if location_closed:
    obs = run(f'open {target_location_ID}')
run(f'move {obj_ID} to {target_location_ID}')
</execute>
