[Input]
当前要展开的函数是：
solve(instruction, observation)
你可以使用的变量是：
- instruction (str): 你的任务是：将两部手机放在沙发上。
- observation (str): 你在房间中间。快速环顾四周，你看到一个咖啡桌 1、餐桌 1、抽屉 4、抽屉 3、抽屉 2、抽屉 1、梳妆台 1、垃圾桶 1、茶几 2、茶几 1 和沙发 1。

[Output]
这个函数必须保持高层次——仅使用给定的占位符辅助函数，绝不使用任何原始 `run(...)` 调用。首先，根据指令和观察，我们声明需要的变量。然后展开应该分解为两个具体阶段：（1）找到并拿起一部手机，（2）将手机放在沙发上。因为我一次只能携带一个物品，我必须严格遵循这个顺序：（1）找到并拿起一部手机，（2）将手机放在沙发上。我绝不能在放置第一个之前搜索两个物品。我绝不能重新排序、合并或内联任何步骤。违反这些规则将产生不正确的行为。


<execute>
obj, target_location_ID, all_location_IDs = declare_init_vars(instruction, observation)

obj_ID, location_ID = find_and_take(obj, all_location_IDs)
put_on(obj_ID, target_location_ID) # 必须拿起一个并放下一个，因为你不能同时拿着两个

all_location_IDs = update_all_location_IDs(location_ID, target_location_ID, all_location_IDs)

obj_ID = find_and_take_again(obj, all_location_IDs)
put_on_again(obj_ID, target_location_ID)
</execute>




[Input]
当前要展开的函数是：
obj, target_location_ID, all_location_IDs = declare_init_vars(instruction, observation)
你可以使用的变量是：
- instruction (str): 你的任务是：将两部手机放在沙发上。
- observation (str): 你在房间中间。快速环顾四周，你看到一个橱柜 4、橱柜 3、橱柜 2、橱柜 1、咖啡机 1、台面 1、餐桌 3、餐桌 2、餐桌 1、抽屉 1、冰箱 1、垃圾桶 1、微波炉 1、茶几 1、水槽 1、炉灶 4、炉灶 3、炉灶 2、炉灶 1 和烤面包机 1。

[Output]
我需要提取四个变量：obj、target_location_ID 和 all_location_IDs。首先，观察到 obj 和 target_location_ID 可以从指令中获取。在观察中，找到了多个位置，所以使用正则表达式提取它们。最后，声明一个特定的 target_location_ID。


<execute>
target_location_ID = '沙发 1'
obj = 'cellphone'
all_location_IDs = re.findall(r'[a-z]+(?:[a-z]+)? \d+', observation)
</execute>




[Input]
当前要展开的函数是：
obj_ID, location_ID = find_and_take(obj, all_location_IDs)
你可以使用的变量是：
- obj (str): apple
- all_location_IDs (list[str]): ['cabinet 4', 'cabinet 3', 'cabinet 2', 'cabinet 1', 'coffeemachine 1', 'countertop 1', 'diningtable 3', 'diningtable 2', 'diningtable 1', 'drawer 1', 'fridge 1', 'garbagecan 1', 'microwave 1', 'sidetable 1', 'sinkbasin 1', 'stoveburner 4', 'stoveburner 3', 'stoveburner 2', 'stoveburner 1', 'toaster 1']

[Output]
目标是有条理地在房间里导航以找到目标物品的任何实例并拿起它。我将遍历已知位置，总是先导航。如果一个位置没有产生新信息，我会检查它。当一个位置关闭时，我会在搜索前打开它。一旦我观察到具体的 `{obj} k` 提到，我会解析那个确切的 ID 并从当前位置拿起它。常见错误包括导航后不检查（遗漏物品）、未能打开关闭的容器，或在没有完整 `obj_ID` 的情况下拿取。


<execute>
for location_ID in all_location_IDs:
    obs = run(f'go to {location_ID}')
    if 'Nothing happens.' in obs:
        obs = run(f'examine {location_ID}')
    location_closed = 'closed' in obs
    if location_closed:
        obs = run(f'open {location_ID}')
    if f" {obj} " in obs: # 防止名称包含关系
        obj_ID = re.search(rf'\b{obj} \d+\b', obs).group()
        run(f'take {obj_ID} from {location_ID}')
        break
</execute>




[Input]
当前要展开的函数是：
put_in(obj_ID, target_location_ID)
你可以使用的变量是：
- obj_ID (str): apple 1
- target_location_ID (str): sidetable 1

[Output]
我会导航到目标位置，如果没有发生任何事情就检查它，确定它是否关闭，如果需要就打开。然后我会把物品移入里面。这个逻辑支持容器（可打开）和表面（不可打开，但检查也无害）。常见错误：在 `examine` 中使用错误的 ID 或跳过 `location_closed` 检查。


<execute>
obs = run(f'go to {target_location_ID}')
if 'Nothing happens.' in obs:
    obs = run(f'examine {target_location_ID}')
location_closed = 'closed' in obs
if location_closed:
    obs = run(f'open {target_location_ID}')
run(f'move {obj_ID} to {target_location_ID}')
</execute>




[Input]
当前要展开的函数是：
all_location_IDs = update_all_location_IDs(location_ID, target_location_ID, all_location_IDs)
你可以使用的变量是：
- location_ID (str): cabinet 1
- target_location_ID (str): sidetable 1
- all_location_IDs (list[str]): ['cabinet 4', 'cabinet 3', 'cabinet 2', 'cabinet 1', 'coffeemachine 1', 'countertop 1', 'diningtable 3', 'diningtable 2', 'diningtable 1', 'drawer 1', 'fridge 1', 'garbagecan 1', 'microwave 1', 'sidetable 1', 'sinkbasin 1', 'stoveburner 4', 'stoveburner 3', 'stoveburner 2', 'stoveburner 1', 'toaster 1']

[Output]
我会刷新候选列表，以便下一次搜索从上次找到物品的确切容器恢复。我必须从 `all_location_IDs.index(location_ID)` 开始切片——**没有 `+1`**——并且我**绝不**按 `target_location_ID` 索引。切片后，我移除 `target_location_ID` 以避免从目的地再次拿取。在索引中使用 `target_location_ID`、添加 `+1` 或在切片前移除目标都是不正确的。


<execute>
all_location_IDs = all_location_IDs[all_location_IDs.index(location_ID):]
if target_location_ID in all_location_IDs:
    all_location_IDs.remove(target_location_ID)
</execute>




[Input]
当前要展开的函数是：
obj_ID = find_and_take_again(obj, all_location_IDs)
你可以使用的变量是：
- obj (str): apple
- all_location_IDs (list[str]): ['sinkbasin 1', 'stoveburner 4', 'stoveburner 3', 'stoveburner 2', 'stoveburner 1', 'toaster 1']

[Output]
这是刷新后的第二个循环；我必须从更新后的 `all_location_IDs` 重新搜索并获得一个新的确切物品 ID，而不是重用前一个。我将像以前一样遵循相同的安全遍历：去、需要时检查、关闭时打开、解析精确的 `{obj} k` 并拿起它。


<execute>
for location_ID in all_location_IDs:
    obs = run(f'go to {location_ID}')
    if 'Nothing happens.' in obs:
        obs = run(f'examine {location_ID}')
    location_closed = 'closed' in obs
    if location_closed:
        obs = run(f'open {location_ID}')
    if f" {obj} " in obs: # 防止名称包含关系
        obj_ID = re.search(rf'\b{obj} \d+\b', obs).group()
        run(f'take {obj_ID} from {location_ID}')
        break
</execute>




[Input]
当前要展开的函数是：
put_on_again(obj_ID, target_location_ID)
你可以使用的变量是：
- obj_ID (str): apple 1
- target_location_ID (str): sidetable 1

[Output]
这是第二次放置；我保持相同的高层次模式：去目标、如果没有发生任何事情就检查、只有当目标是可关闭的时才打开，然后将物品移到上面。我不会在这里内联任何其他原始动作。


<execute>
obs = run(f'go to {target_location_ID}')
if 'Nothing happens.' in obs:
    obs = run(f'examine {target_location_ID}')
location_closed = 'closed' in obs
if location_closed:
    obs = run(f'open {target_location_ID}')
run(f'move {obj_ID} to {target_location_ID}')
</execute>
